name: Auto label PRs
on:
  workflow_dispatch: {}
permissions:
  contents: read
  issues: write
  pull-requests: write
jobs:
  label:
    runs-on: ubuntu-latest
    steps:
    - name: Ensure main workflow
      if: ${{ github.event_name == 'workflow_dispatch' && github.ref != 'refs/heads/main'
        }}
      run: 'echo "This workflow must be dispatched from main."

        exit 1

        '
    - name: Resolve PR context
      id: pr
      uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd
      env:
        MANUAL_PR_NUMBER: ${{ inputs.pr_number || '' }}
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: "const isManual = context.eventName === 'workflow_dispatch';\nlet\
          \ pr;\nif (isManual) {\n  const prNumber = Number(process.env.MANUAL_PR_NUMBER);\n\
          \  if (!prNumber) {\n    core.setFailed('workflow_dispatch requires pr_number\
          \ input.');\n    return;\n  }\n  const { data } = await github.rest.pulls.get({\n\
          \    owner: context.repo.owner,\n    repo: context.repo.repo,\n    pull_number:\
          \ prNumber,\n  });\n  pr = data;\n} else {\n  pr = context.payload.pull_request;\n\
          }\nif (!pr) {\n  core.setFailed('Missing pull request context.');\n  return;\n\
          }\nconst headRepo = pr.head.repo.full_name;\nconst repoFullName = `${context.repo.owner}/${context.repo.repo}`;\n\
          core.setOutput('pr_number', pr.number);\ncore.setOutput('base_sha', pr.base.sha);\n\
          core.setOutput('head_sha', pr.head.sha);\ncore.setOutput('head_repo', headRepo);\n\
          core.setOutput('is_fork', headRepo !== repoFullName);\n"
    - name: Checkout base
      uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8
      with:
        fetch-depth: 0
        ref: ${{ steps.pr.outputs.base_sha }}
    - name: Fetch PR head
      env:
        PR_HEAD_REPO: ${{ steps.pr.outputs.head_repo }}
        PR_HEAD_SHA: ${{ steps.pr.outputs.head_sha }}
      run: "set -euo pipefail\ngit fetch --no-tags --prune --recurse-submodules=no\
        \ \\\n  \"https://github.com/${PR_HEAD_REPO}.git\" \\\n  \"${PR_HEAD_SHA}\"\
        \n"
    - name: Collect PR diff
      env:
        PR_BASE_SHA: ${{ steps.pr.outputs.base_sha }}
        PR_HEAD_SHA: ${{ steps.pr.outputs.head_sha }}
      run: 'set -euo pipefail

        mkdir -p .tmp/pr-labels

        git diff --name-only "$PR_BASE_SHA" "$PR_HEAD_SHA" > .tmp/pr-labels/changed-files.txt

        git diff "$PR_BASE_SHA" "$PR_HEAD_SHA" > .tmp/pr-labels/changes.diff

        '
    - name: Prepare Codex output
      id: codex-output
      run: 'set -euo pipefail

        output_dir=".tmp/codex/outputs"

        output_file="${output_dir}/pr-labels.json"

        mkdir -p "$output_dir"

        echo "output_file=${output_file}" >> "$GITHUB_OUTPUT"

        '
    - name: Run Codex labeling
      id: run_codex
      if: ${{ (github.event_name == 'workflow_dispatch' || steps.pr.outputs.is_fork
        != 'true') && github.actor != 'dependabot[bot]' }}
      uses: openai/codex-action@086169432f1d2ab2f4057540b1754d550f6a1189
      with:
        openai-api-key: ${{ secrets.PROD_OPENAI_API_KEY }}
        prompt-file: .github/codex/prompts/pr-labels.md
        output-file: ${{ steps.codex-output.outputs.output_file }}
        safety-strategy: drop-sudo
        sandbox: read-only
    - name: Apply labels
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        PR_NUMBER: ${{ steps.pr.outputs.pr_number }}
        PR_BASE_SHA: ${{ steps.pr.outputs.base_sha }}
        PR_HEAD_SHA: ${{ steps.pr.outputs.head_sha }}
        CODEX_OUTPUT_PATH: ${{ steps.codex-output.outputs.output_file }}
        CODEX_CONCLUSION: ${{ steps.run_codex.conclusion }}
      run: "python - <<'PY'\nimport json\nimport os\nimport pathlib\nimport subprocess\n\
        import re\n\npr_number = os.environ[\"PR_NUMBER\"]\npr_base_sha = os.environ.get(\"\
        PR_BASE_SHA\")\npr_head_sha = os.environ.get(\"PR_HEAD_SHA\")\ncodex_output_path\
        \ = pathlib.Path(os.environ[\"CODEX_OUTPUT_PATH\"])\ncodex_conclusion = os.environ.get(\"\
        CODEX_CONCLUSION\", \"\").strip().lower()\nchanged_files_path = pathlib.Path(\"\
        .tmp/pr-labels/changed-files.txt\")\nchanges_diff_path = pathlib.Path(\".tmp/pr-labels/changes.diff\"\
        )\n\ncodex_ran = bool(codex_conclusion) and codex_conclusion != \"skipped\"\
        \n\ndef read_file_at(commit, path):\n    if not commit:\n        return None\n\
        \    try:\n        return subprocess.check_output(\n            [\"git\",\
        \ \"show\", f\"{commit}:{path}\"],\n            text=True,\n        )\n  \
        \  except subprocess.CalledProcessError:\n        return None\n\ndef dependency_lines_for_pyproject(text:\
        \ str) -> set[int]:\n    dependency_lines: set[int] = set()\n    current_section\
        \ = None\n    in_project_dependencies = False\n\n    for line_number, raw_line\
        \ in enumerate(text.splitlines(), start=1):\n        stripped = raw_line.strip()\n\
        \        if stripped.startswith(\"[\") and stripped.endswith(\"]\"):\n   \
        \         if stripped.startswith(\"[[\") and stripped.endswith(\"]]\"):\n\
        \                current_section = stripped[2:-2].strip()\n            else:\n\
        \                current_section = stripped[1:-1].strip()\n            in_project_dependencies\
        \ = False\n            if current_section in (\"project.optional-dependencies\"\
        , \"dependency-groups\"):\n                dependency_lines.add(line_number)\n\
        \            continue\n\n        if current_section in (\"project.optional-dependencies\"\
        , \"dependency-groups\"):\n            dependency_lines.add(line_number)\n\
        \            continue\n\n        if current_section != \"project\":\n    \
        \        continue\n\n        if in_project_dependencies:\n            dependency_lines.add(line_number)\n\
        \            if \"]\" in stripped:\n                in_project_dependencies\
        \ = False\n            continue\n\n        if stripped.startswith(\"dependencies\"\
        ) and \"=\" in stripped:\n            dependency_lines.add(line_number)\n\
        \            if \"[\" in stripped and \"]\" not in stripped:\n           \
        \     in_project_dependencies = True\n\n    return dependency_lines\n\ndef\
        \ pyproject_dependency_changed(diff_text: str) -> bool:\n    base_text = read_file_at(pr_base_sha,\
        \ \"pyproject.toml\")\n    head_text = read_file_at(pr_head_sha, \"pyproject.toml\"\
        )\n    if base_text is None and head_text is None:\n        return False\n\
        \n    base_dependency_lines = (\n        dependency_lines_for_pyproject(base_text)\
        \ if base_text else set()\n    )\n    head_dependency_lines = (\n        dependency_lines_for_pyproject(head_text)\
        \ if head_text else set()\n    )\n\n    in_pyproject = False\n    base_line\
        \ = None\n    head_line = None\n    hunk_re = re.compile(r\"@@ -(\\d+)(?:,\\\
        d+)? \\+(\\d+)(?:,\\d+)? @@\")\n\n    for line in diff_text.splitlines():\n\
        \        if line.startswith(\"+++ b/\"):\n            current_file = line[len(\"\
        +++ b/\") :].strip()\n            in_pyproject = current_file == \"pyproject.toml\"\
        \n            base_line = None\n            head_line = None\n           \
        \ continue\n\n        if not in_pyproject:\n            continue\n\n     \
        \   if line.startswith(\"@@ \"):\n            match = hunk_re.match(line)\n\
        \            if not match:\n                continue\n            base_line\
        \ = int(match.group(1))\n            head_line = int(match.group(2))\n   \
        \         continue\n\n        if base_line is None or head_line is None:\n\
        \            continue\n\n        if line.startswith(\" \"):\n            base_line\
        \ += 1\n            head_line += 1\n            continue\n\n        if line.startswith(\"\
        -\"):\n            if base_line in base_dependency_lines:\n              \
        \  return True\n            base_line += 1\n            continue\n\n     \
        \   if line.startswith(\"+\"):\n            if head_line in head_dependency_lines:\n\
        \                return True\n            head_line += 1\n            continue\n\
        \n    return False\n\nchanged_files = []\nif changed_files_path.exists():\n\
        \    changed_files = [\n        line.strip()\n        for line in changed_files_path.read_text().splitlines()\n\
        \        if line.strip()\n    ]\n\ndesired = set()\nif \"pyproject.toml\"\
        \ in changed_files:\n    desired.add(\"project\")\nif any(path.startswith(\"\
        docs/\") for path in changed_files):\n    desired.add(\"documentation\")\n\
        dependencies_allowed = \"uv.lock\" in changed_files\ndiff_text = None\nif\
        \ changes_diff_path.exists():\n    diff_text = changes_diff_path.read_text()\n\
        \    if \"pyproject.toml\" in changed_files and pyproject_dependency_changed(diff_text):\n\
        \        dependencies_allowed = True\n\nif dependencies_allowed:\n    desired.add(\"\
        dependencies\")\n\nif not codex_ran:\n    feature_prefixes = {\n        \"\
        feature:realtime\": (\n            \"src/agents/realtime/\",\n           \
        \ \"tests/realtime/\",\n            \"examples/realtime/\",\n            \"\
        docs/realtime/\",\n        ),\n        \"feature:voice\": (\n            \"\
        src/agents/voice/\",\n            \"tests/voice/\",\n            \"examples/voice/\"\
        ,\n            \"docs/voice/\",\n        ),\n        \"feature:mcp\": (\n\
        \            \"src/agents/mcp/\",\n            \"tests/mcp/\",\n         \
        \   \"examples/mcp/\",\n            \"examples/hosted_mcp/\",\n          \
        \  \"docs/mcp/\",\n        ),\n        \"feature:tracing\": (\n          \
        \  \"src/agents/tracing/\",\n            \"tests/tracing/\",\n           \
        \ \"docs/tracing/\",\n            \"examples/tracing/\",\n        ),\n   \
        \     \"feature:sessions\": (\n            \"src/agents/memory/\",\n     \
        \       \"tests/memory/\",\n            \"examples/memory/\",\n          \
        \  \"docs/memory/\",\n        ),\n    }\n\n    for label, prefixes in feature_prefixes.items():\n\
        \        if any(path.startswith(prefix) for prefix in prefixes for path in\
        \ changed_files):\n            desired.add(label)\n\n    if any(\n       \
        \ \"chatcmpl\" in path or \"chatcompletions\" in path for path in changed_files\n\
        \    ):\n        desired.add(\"feature:chat-completions\")\n\n    if any(\"\
        litellm\" in path for path in changed_files):\n        desired.add(\"feature:lite-llm\"\
        )\n\n    excluded_core_prefixes = (\n        \"src/agents/realtime/\",\n \
        \       \"src/agents/voice/\",\n        \"src/agents/mcp/\",\n        \"src/agents/tracing/\"\
        ,\n        \"src/agents/memory/\",\n        \"src/agents/extensions/\",\n\
        \    )\n    if any(\n        path.startswith(\"src/agents/\")\n        and\
        \ not path.startswith(excluded_core_prefixes)\n        for path in changed_files\n\
        \    ):\n        desired.add(\"feature:core\")\n\nallowed = {\n    \"documentation\"\
        ,\n    \"project\",\n    \"bug\",\n    \"enhancement\",\n    \"dependencies\"\
        ,\n    \"feature:chat-completions\",\n    \"feature:core\",\n    \"feature:lite-llm\"\
        ,\n    \"feature:mcp\",\n    \"feature:realtime\",\n    \"feature:sessions\"\
        ,\n    \"feature:tracing\",\n    \"feature:voice\",\n}\n\ncodex_labels = []\n\
        if codex_output_path.exists():\n    raw = codex_output_path.read_text().strip()\n\
        \    if raw:\n        try:\n            payload = json.loads(raw)\n      \
        \      if isinstance(payload, dict):\n                labels = payload.get(\"\
        labels\", [])\n                if isinstance(labels, list):\n            \
        \        codex_labels = [label for label in labels if isinstance(label, str)]\n\
        \        except json.JSONDecodeError:\n            pass\n\nfor label in codex_labels:\n\
        \    if label == \"dependencies\" and not dependencies_allowed:\n        continue\n\
        \    if label in allowed:\n        desired.add(label)\n\nresult = subprocess.check_output(\n\
        \    [\"gh\", \"pr\", \"view\", pr_number, \"--json\", \"labels\", \"--jq\"\
        , \".labels[].name\"],\n    text=True,\n).strip()\nexisting = {label for label\
        \ in result.splitlines() if label}\n\nmanaged = set(allowed) if codex_ran\
        \ else set()\nto_add = sorted(desired - existing)\nto_remove = sorted((existing\
        \ & managed) - desired)\n\nif not to_add and not to_remove:\n    print(\"\
        Labels already up to date.\")\n    raise SystemExit(0)\n\ncmd = [\"gh\", \"\
        pr\", \"edit\", pr_number]\nif to_add:\n    cmd += [\"--add-label\", \",\"\
        .join(to_add)]\nif to_remove:\n    cmd += [\"--remove-label\", \",\".join(to_remove)]\n\
        \nsubprocess.check_call(cmd)\nPY\n"
    - name: Comment on manual run failure
      if: ${{ github.event_name == 'workflow_dispatch' && always() }}
      uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd
      env:
        PR_NUMBER: ${{ steps.pr.outputs.pr_number }}
        JOB_STATUS: ${{ job.status }}
        RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{
          github.run_id }}
        CODEX_CONCLUSION: ${{ steps.run_codex.conclusion }}
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: "const marker = '<!-- pr-labels-manual-run -->';\nconst jobStatus\
          \ = process.env.JOB_STATUS;\nif (jobStatus === 'success') {\n  return;\n\
          }\nconst prNumber = Number(process.env.PR_NUMBER);\nif (!prNumber) {\n \
          \ core.setFailed('Missing PR number for manual run comment.');\n  return;\n\
          }\nconst body = [\n  marker,\n  'Manual PR labeling failed.',\n  `Job status:\
          \ ${jobStatus}.`,\n  `Run: ${process.env.RUN_URL}.`,\n  `Codex labeling:\
          \ ${process.env.CODEX_CONCLUSION}.`,\n].join('\\n');\nconst { data: comments\
          \ } = await github.rest.issues.listComments({\n  owner: context.repo.owner,\n\
          \  repo: context.repo.repo,\n  issue_number: prNumber,\n  per_page: 100,\n\
          });\nconst existing = comments.find(\n  (comment) =>\n    comment.user?.login\
          \ === 'github-actions[bot]' &&\n    comment.body?.includes(marker),\n);\n\
          if (existing) {\n  await github.rest.issues.updateComment({\n    owner:\
          \ context.repo.owner,\n    repo: context.repo.repo,\n    comment_id: existing.id,\n\
          \    body,\n  });\n  core.info(`Updated existing comment ${existing.id}`);\n\
          \  return;\n}\nconst { data: created } = await github.rest.issues.createComment({\n\
          \  owner: context.repo.owner,\n  repo: context.repo.repo,\n  issue_number:\
          \ prNumber,\n  body,\n});\ncore.info(`Created comment ${created.id}`);\n"
